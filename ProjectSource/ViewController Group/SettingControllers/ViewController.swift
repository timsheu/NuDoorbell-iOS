//
//  ViewController.swift
//  customButton
//
//  Created by CCHSU20 on 11/11/2016.
//  Copyright Â© 2016 CCHSU20. All rights reserved.
//

import UIKit
import ASToast
import ReachabilitySwift

class ViewController: UIViewController, UICollectionViewDelegate, UICollectionViewDataSource, UICollectionViewDelegateFlowLayout, EditDBTableDelegate, BroadcastReceiverDelegate{
    var cameraIP = ""
    var items = Array<[String: Any]>()
    /*
     item contains:
        "id": id generated by SharkORM, unique ID of the database
        "name": name of the device that set by user
        "type": device type, like NuDoorbell, SkyEye, NuWicam
        "publicIP": public IP of the device
        "uuid": uuid of the device, received from LAN broadcast packet or set by user
     */
    var onClickIndex: IndexPath?
    var deviceData: DeviceData?
    @IBOutlet weak var collection: UICollectionView!
    override func viewDidLoad() {
        super.viewDidLoad()
        for result in DeviceData.query().fetch(){
            let device = result as! DeviceData
            let name = device.name
            let id = device.id
            let publicIP = device.publicIP
            let type = device.deviceType
            let uuid = device.uuid
            let isAlive = false
            let item: [String: Any] = ["name": name, "id": id, "publicIP": publicIP, "type": type, "uuid": uuid, "isAlive": isAlive]
            print("Dic: \(item)")
            items.append(item)
        }
        BroadcastReceiver.sharedInstance().delegate = self
        BroadcastReceiver.sharedInstance().openBroadcastReceiver()
        // Do any additional setup after loading the view, typically from a nib.
    }
    
    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }

    func numberOfSections(in collectionView: UICollectionView) -> Int {
        return 1
    }
    
    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
        let count = Int(DeviceData.query().count())
        return count + 1
    }
    
    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        var identifier = "Cell"
        if indexPath.item == self.items.count {
            identifier = "Plus"
        }
        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: identifier, for: indexPath)
        
        if identifier == "Cell" {
            let label: UILabel = cell.viewWithTag(10) as! UILabel
            let indicator: UIImageView = cell.viewWithTag(11) as! UIImageView
            let button: UIImageView = cell.viewWithTag(12) as! UIImageView
            let dic = self.items[indexPath.item]
            label.text = dic["name"] as? String
            var indicatorString = "STATUS_R"
            let isAlive = dic["isAlive"] as! Bool
            if isAlive{
                indicatorString = "STATUS_G"
            }
            indicator.image = UIImage(named: indicatorString)
            button.image = UIImage(named: "db")
            let tap = UITapGestureRecognizer.init(target: self, action: #selector(ViewController.singleTap(gesture:)))
            let long = UILongPressGestureRecognizer.init(target: self, action: #selector(ViewController.longPress(gesture:)))
            cell.addGestureRecognizer(tap)
            cell.addGestureRecognizer(long)
        }else {
            // identifier == "Plus" do not need to be handled
        }
        
        return cell
    }
    
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize {
        return CGSize.init(width: 108, height: 108)
    }
    
    
    
    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        let table = segue.destination as! EditDBTableViewController
        var dic = [String: Any]();
        table.delegate = self
        if segue.identifier == "Edit" {
            dic = items[(onClickIndex?.item)!]
        }
        table.passData(dictionary: dic)
    }
    
    //MARK: EditDBTable delegate
    func editDevice(setting: [String: Any]) {
        print("editDevice: \(setting)")
        if let row = setting["id"]{
            let row = row as! NSNumber
            let queryString = String(format: "id = %@", row)
            let result = DeviceData.query().where(queryString).fetch()
            print("\(setting)")
            let deviceData = result?[0] as! DeviceData
            deviceData.name = setting["name"] as? String
            deviceData.deviceType = setting["type"] as? String
            deviceData.publicIP = setting["publicIP"] as? String
            deviceData.privateIP = setting["publicIP"] as? String
            deviceData.uuid = setting["uuid"] as? String
            _ = deviceData.commit()
            
            print("device count: \(DeviceData.query().count())")
            if items.count > 0 {
                items[(onClickIndex?.item)!] = setting
            }else {
                items.append(setting)
            }
        }
        collection.reloadData()
    }
    
    //MARK: short/long click event
    func singleTap(gesture: UITapGestureRecognizer){
//        print("\(gesture.location(in: collection))" + " tap")
        let point = gesture.location(in: collection)
        let indexpath = collection.indexPathForItem(at: point)
        onClickIndex = indexpath
        let item = items[(onClickIndex?.item)!]
        let deviceID: NSNumber = item["id"] as! NSNumber
        let device = getTargetDevice(deviceID: deviceID)
        openLiveStream(deviceData: device)
    }
    
    func longPress(gesture: UILongPressGestureRecognizer){
//        print("\(gesture.location(in: collection))" + " press")
        let point = gesture.location(in: collection)
        let indexpath = collection.indexPathForItem(at: point)
        onClickIndex = indexpath
        if  gesture.state == .began{
            let alert = UIAlertController(title: "Device Option", message: "Select action for next step", preferredStyle: .actionSheet)
            
            let cancel = UIAlertAction(title: "Cancel", style: .cancel, handler: nil)
            alert.addAction(cancel)
            
            let remove = UIAlertAction(title: "Remove", style: .destructive, handler: { UIAlertAction in
                let item = self.items[(self.onClickIndex?.item)!]
                let id = item["id"] as! NSNumber
                if let result = DeviceData.query().where(withFormat: "id = %@", withParameters: [id]).fetch(){
                    let device = result[0] as! DeviceData
                    device.remove()
                    device.commit()
                }
                self.items.remove(at: (self.onClickIndex?.item)!)
                self.collection.reloadData()
            })
            alert.addAction(remove)
            
            let edit = UIAlertAction(title: "Edit", style: .default, handler: { UIAlertAction in
                self.performSegue(withIdentifier: "Edit", sender: nil)
            })
            alert.addAction(edit)
            
            let filelist = UIAlertAction(title: "Remote File List", style: .default, handler: {UIAlertAction in
                
            })
            present(alert, animated: true, completion: nil)
        }
    }
    
    //MARK: Broadcast Receiver Delegate
    func showToast(message: String) {
        self.view.makeToast(message)
    }
    
    func gotRingMessage(uuid: String) {
        let ringDevice = getTargetDevice(deviceUuid: uuid)
        openDialog(deviceData: ringDevice)
    }
    
    //MARK: Utility
    func openLiveStream(deviceData: DeviceData) {
        let parameters = [KxMovieParameterDisableDeinterlacing:true]
        let deviceID: NSNumber = deviceData.id
        cameraIP = deviceData.publicIP!
        print("deviceID: \(deviceID), cameraURL: \(cameraIP)")
        let n329URL = "rtsp://" + cameraIP + "/cam1/h264"
        let kxmovie = KxMovieViewController.movieViewController(withContentPath: n329URL, parameters: parameters as [AnyHashable: Any], deviceID: deviceID)
        self.present(kxmovie as! KxMovieViewController, animated: true, completion: nil)
    }
    
    func openDialog(deviceData: DeviceData) -> Void {
        let alert = UIAlertController(title: "Ringing!", message: "Doorbell is ringing, show live stream now?", preferredStyle: .alert)
        let cancel = UIAlertAction(title: "Nope.", style: .cancel, handler: nil)
        let stream = UIAlertAction(title: "Now!", style: .default, handler: {
            (action: UIAlertAction!) -> Void in
            self.openLiveStream(deviceData: deviceData)
        })
        alert.addAction(cancel)
        alert.addAction(stream)
        self.present(alert, animated: true, completion: nil)

    }
    
    func getTargetDevice(deviceID: NSNumber) -> DeviceData {
        let result = DeviceData.query().where(withFormat: "id = %@", withParameters: [deviceID]).fetch()
        var device = DeviceData.init()
        switch (result?.count)! {
        case 1:
            device = result?[0] as! DeviceData
            break
        default:
            print("device amount is not one, return default data!")
            break
        }
        return device
    }
    
    func getTargetDevice(deviceUuid: String) -> DeviceData {
        let result = DeviceData.query().where(withFormat: "uuid = %@", withParameters: [deviceUuid]).fetch()
        var device = DeviceData.init()
        switch (result?.count)! {
        case 1:
            device = result?[0] as! DeviceData
            print("device: \(device)")
            break
        default:
            print("device amount is not one, return default data!")
            break
        }
        return device
    }
    
    func updateIndicator() -> Void {
        for var item in items {
            let publicIP = item["PublicIP"] as! String
            let reachability = Reachability.init(hostname: publicIP)
            reachability?.whenReachable = { reachability in
                item["isAlive"] = true
            }
            reachability?.whenUnreachable = { reachability in
                item["isAlive"] = false
            }
        }
        collection.reloadData()
    }
}

